# Android-State

A utility library for Android to save objects in a `Bundle` without any boilerplate. It uses an annotation processor to wire up all dependencies.

## Download

Download [the latest version](http://search.maven.org/#search|gav|1|g:"com.evernote"%20AND%20a:"android-state") or grab via Gradle:

```groovy
dependencies {
    compile 'com.evernote:android-state:0.0.1'
    annotationProcessor 'com.evernote:android-state-processor:0.0.1'
}
```

You can read the [JavaDoc here](https://evernote.github.io/android-state/javadoc/).

## Usage

Annotate any field with `@State` and use the `StateSaver` class to save those fields in a Bundle. This works from an `Activity` or `Fragment`, but also from anywhere else in your code. You can save any type which can be saved in a Bundle like the `String`, `Serializable`, and `Parcelable` data structures.

```java
public class MainActivity extends Activity {

    @State
    public int mValue;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        StateSaver.restoreInstanceState(this, savedInstanceState);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        StateSaver.saveInstanceState(this, outState);
    }
}
```

## Advanced

You can also save state in a `View` class.

```java
public class TestView extends View {

    @State
    public int mState;

    public TestView(Context context) {
        super(context);
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        return StateSaver.saveInstanceState(this, super.onSaveInstanceState());
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        super.onRestoreInstanceState(StateSaver.restoreInstanceState(this, state));
    }
}
```

It is recommended that saved properties not be `private`. If a property is `private`, then a non-private getter and setter method are required. This is especially useful for Kotlin, because properties are `private` by default and the aforementioned methods are generated by the compiler.

```kotlin
class DemoPresenter : Presenter<DemoView>() {

    @State
    var counter = 0

    // ...
}

```

Of course, this also works in Java.

```java
public class TitleUpdater {

    @State
    private String mTitle;

    public String getTitle() {
        return mTitle;
    }

    public void setTitle(String title) {
        mTitle = title;
    }
}
```

If you have a private field and don't want to provide a getter or setter method, then you can fallback to reflection. However, this method is not recommended.

```java
public class ImageProcessor {

    @State(reflection = true)
    private byte[] mImageData;

    // ...
}
```

A custom bundler can be useful, if a class doesn't implement the `Parcelable` or `Serializable` interface, which oftentimes happens with third party dependencies.

```java
public class MappingProvider {

    @State(PairBundler.class)
    public Pair<String, Integer> mMapping;

    public static final class PairBundler implements Bundler<Pair<String, Integer>> {
        @Override
        public void put(@NonNull String key, @NonNull Pair<String, Integer> value, @NonNull Bundle bundle) {
            bundle.putString(key + "first", value.first);
            bundle.putInt(key + "second", value.second);
        }

        @Nullable
        @Override
        public Pair<String, Integer> get(@NonNull String key, @NonNull Bundle bundle) {
            if (bundle.containsKey(key + "first")) {
                return new Pair<>(bundle.getString(key + "first"), bundle.getInt(key + "second"));
            } else {
                return null;
            }
        }
    }
}
```

#### ProGuard

This library comes with a ProGuard config. No further steps are required, but all necessary rules can be found [here](library/proguard.cfg).

## [Icepick](https://github.com/frankiesardo/icepick)

This library is based on [Icepick](https://github.com/frankiesardo/icepick), a great library from Frankie Sardo. However, Icepick is missing some features important to us: it [doesn't support properties](https://github.com/frankiesardo/icepick/issues/81) which is a [bummer for Kotlin](https://github.com/frankiesardo/icepick/issues/47). Also, Icepick does not support private fields which may break encapsulation. A tool shouldn't force you into this direction.

Since Icepick is implemented in Clojure, we decided that's it's better for us to rewrite the annotation processor in Java. Unfortunately, that makes it hard to push our features into Icepick itself. That's why we decided to fork the project.

There are also alternatives for Kotlin like [IceKick](https://github.com/tinsukE/icekick). We did not want to use two libraries to solve the same problem for two different languages; we wanted to have one solution for all scenarios.

Upgrading to this library from Icepick is easy. The API is the same; only the packages and the class name (i.e. from `Icepick` to `StateSaver`) have changed. If Icepick works well for you, then there's no need to upgrade.

## License

    Copyright (c) 2007-2017 by Evernote Corporation, All rights reserved.

    Use of the source code and binary libraries included in this package
    is permitted under the following terms:

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
        2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
